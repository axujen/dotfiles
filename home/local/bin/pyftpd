#!/usr/bin/env python
## vim: ft=python
## ~/.local/bin/pyftpd: small ftp server that uses pyftpdlib
## usernames and directories are in ~/.config/pyftpd/users
## NOTE: it only accepts connections from 192.168.*.* and 127.0.0.1 addresses
##
## TODO: Harden security further?
## TODO: Fix messy code, mainly path expansion and file handling

import os,sys,re,sys,hashlib,binascii,uuid,errno,logging,atexit,signal,stat
from argparse import ArgumentParser
try: from ConfigParser import ConfigParser # python2
except ImportError: from configparser import ConfigParser # python3

from pyftpdlib.authorizers import DummyAuthorizer, AuthenticationFailed
from pyftpdlib.handlers import FTPHandler
from pyftpdlib.servers import FTPServer
from pyftpdlib.filesystems import AbstractedFS
from pyftpdlib.log import LogFormatter

# Initialize default config
CONFIGFILE="~/.config/pyftpd/config"
CONFIG=ConfigParser()
CONFIG.add_section("general")
CONFIG.add_section("server")
CONFIG.set("general", "usersfile", "~/.config/pyftpd/users")
CONFIG.set("general", "logfile", "~/.config/pyftpd/log")
CONFIG.set("general", "pidfile", "~/.config/pyftpd/pid")
CONFIG.set("server", "address", "0.0.0.0")
CONFIG.set("server", "port", "2121")
CONFIG.read(os.path.expanduser(CONFIGFILE)) # overwrite defaults from file

# Globals
PIDFILE=CONFIG.get("general", "pidfile")
LOGFILE=CONFIG.get("general", "logfile")
USERSFILE=CONFIG.get("general", "usersfile")
USERSDB=None
PERMS={ "READ":   "elr",
        "WRITE":  "afmw",
        "DELETE": "d",
        "CHMOD":  "W"}

def _empty(string): return not string or string.isspace()

def _readline(string):
    sys.stdout.write(string)
    sys.stdout.flush()
    return sys.stdin.readline().rstrip()

def Salt():
    return uuid.uuid4().hex

def Hash(password, salt):
    return binascii.hexlify(hashlib.pbkdf2_hmac('sha256', password.encode(), salt.encode(), 1000000)).decode()

def AddUser():
    """Create a config section for a user"""
    db=LoadUsers(USERSFILE)
    while True:
        while True:
            name = _readline("username: ")
            if _empty(name):
                print("A username must be supplied")
                continue
            elif name in db.keys():
                print("user %s already exists" % name)
                continue
            break
        while True:
            root = _readline("root folder: ")
            if _empty(root):
                print("A path must be supplied")
                continue
            break
        while True:
            writeable = _readline("make root writeable? (y/N): ")
            if writeable.isspace() or writeable.lower() in ("no" or "n"):
                writeable = False
            elif writeable.lower() in ("yes" or "y"):
                writeable = True
            else:
                print("Yes or No, press space for no")
                continue
            break
        uploads = _readline("writeable uploads directory, relative to root (leave empty to disable): ")
        if _empty(uploads): uploads = None

        while True:
            password = _readline("password: ")
            if _empty(password):
                print("A password must be supplied")
                continue
            break
        break

    salt = str(Salt())
    hash = str(Hash(password, salt))

    db[name]={}
    db[name]["root"]=root
    db[name]["writeable"]=writeable
    db[name]["uploads"]=uploads
    db[name]["hash"]=hash
    db[name]["salt"]=salt
    return name, db[name]

def LoadUsers(file=USERSFILE):
    """Load and check user database, return a dictionary"""
    global USERSDB # all changes should sync to this
    if USERSDB: return USERSDB # don't load from file more than once

    file = os.path.expanduser(file)
    config = ConfigParser()
    config.read(file)

    db = {}
    for user in config.sections():
        db[user] = {}
        # mandatory
        db[user]["hash"] = config.get(user, "hash")
        db[user]["salt"] = config.get(user, "salt")
        db[user]["root"] = os.path.abspath(os.path.expanduser(config.get(user, "root")))

        # optional
        if config.has_option(user, "write"):
            db[user]["writeable"] = config.getboolean(user, "writeable")
        else:
            db[user]["writeable"] = False

        if config.has_option(user, "uploads"):
            db[user]["uploads"] = config.get(user, "uploads")
        else:
            db[user]["uploads"] = None

    USERSDB=db # assign to global
    return db

def _makedirs(path):
    """Create the directory tree leading to path"""
    parent=os.path.dirname(path)
    try:
        os.makedirs(parent)
    except OSError as e:
        if e.errno == errno.EEXIST: # directory already exists
            pass

def _openfile(path):
    """Open a file making sure it exists"""
    # TODO: Fix this mess
    path=os.path.expanduser(path)
    try:
        fd=open(path, 'w')
    except IOError as e:
        if e.errno == 2: # No such file or directory
            _makedirs(path)

        fd=open(path, 'w')
    return fd

def WriteConfig(config, path):
    path=os.path.expanduser(path)
    try:
        fd=_openfile(path)
    except:
        print("Cannot open file %s, check your permissions or create it manually" % path)
        sys.exit(1)

    try:
        fd.write("# vim: ft=dosini" + os.linesep)
        config.write(fd)
    finally:
        fd.close()

def WriteUsers(db, path):
    path=os.path.expanduser(path)
    try:
        fd=_openfile(path)
    except:
        print("Cannot open file %s, check your permissions or create it manually" % path)
        sys.exit(1)

    config=ConfigParser()
    for user,values in db.items():
        config.add_section(user)
        config.set(user, "root", db[user]["root"] )
        if db[user]["writeable"]:
            config.set(user, "writeable", "yes")
        else:
            config.set(user, "writeable", "no")
        if db[user]["uploads"]:
            config.set(user, "uploads", db[user]["uploads"])
        config.set(user, "hash", db[user]["hash"])
        config.set(user, "salt", db[user]["salt"])

    try:
        fd.write("# vim: ft=dosini" + os.linesep)
        config.write(fd)
    finally:
        fd.close()
        # set it to read-only
        os.chmod(path, stat.S_IRUSR | stat.S_IWUSR)

class FTPLocalHandler(FTPHandler):
    """Rejects connections that do not originate from the local networ"""
    _localnet = re.compile("|".join([ r'^192\.168\.\d*\.\d*$', r'^127\.0\.0\.1$' ]))
    def __init__(self, *args, **kwargs):
        FTPHandler.__init__(self, *args, **kwargs)
        if not self._localnet.match(self.remote_ip):
            self.close()
            self.log("remote ip (%s) does not match local network filter." % self.remote_ip)
            return

class DummyHashAuthorizer(DummyAuthorizer):
    """Authorizer that uses hashes instead, see: https://pythonhosted.org/pyftpdlib/tutorial.html#storing-passwords-as-hash-digests"""
    def add_user(self, username, salt, *args, **kwargs):
        DummyAuthorizer.add_user(self, username, *args, **kwargs)
        self.user_table[username]['salt'] = salt

    def validate_authentication(self, username, password, handler):
        msg = "Authentication failed."
        if not self.has_user(username):
            if username == 'anonymous':
                msg = "Anonymous access not allowed."
            raise AuthenticationFailed(msg)
        if username != 'anonymous':
            hash=Hash(password, self.user_table[username]["salt"])
            try:
                if self.user_table[username]['pwd'] != hash:
                    raise KeyError
            except KeyError:
                raise AuthenticationFailed("Authentication failed.")

def InitServer(address, port, userdb):
    """Initialize server without starting it"""
    # Check if server is running
    pidfile=os.path.expanduser(PIDFILE)
    if os.path.isfile(pidfile): # Check if already running
        with open(pidfile, "r") as fd:
            pid=fd.readline()
            print("Another instance is already running at PID %s" % pid)
            sys.exit(1)

    authorizer = DummyHashAuthorizer()
    handler = FTPLocalHandler
    handler.authorizer = authorizer

    # Load users
    for user,db in userdb.items():
        if db["writeable"]:
            authorizer.add_user(user, db["salt"], db["hash"], db["root"], perm=PERMS["READ"] + PERMS["WRITE"])
        else:
            authorizer.add_user(user, db["salt"], db["hash"], db["root"], perm=PERMS["READ"])
        if db["uploads"]:
            uploads = "/".join((db["root"], db["uploads"]))
            authorizer.override_perm(user, uploads, perm=PERMS["READ"] + PERMS["WRITE"], recursive=True)


    # configure logging
    # to file
    logfile=os.path.expanduser(CONFIG.get("general", "logfile"))
    logging.basicConfig(filename=logfile, level=logging.DEBUG)

    # to stdout
    log = logging.getLogger('pyftpdlib')
    stdout=logging.StreamHandler(sys.stdout)
    stdout.setLevel(logging.INFO)
    stdout.setFormatter(LogFormatter())
    log.addHandler(stdout)

    # Load server settings
    server = FTPServer((address, port), handler)

    return server

def StartServer(server):
    """Lock a pidfile and start the server"""

    # Unlock pidfile
    def _unlockpid(*args): 
        pidfile=os.path.expanduser(PIDFILE)
        if os.path.exists(pidfile):
            os.remove(pidfile)

    # Write the forked pid
    pidfile=os.path.expanduser(PIDFILE)

    try:
        with open(pidfile, "w") as pid:
            pid.write(str(os.getpid()))

        def _sigterm_handler(_signo, _stack_frame):
            sys.exit(0) # Just let the context manager handle it

        signal.signal(signal.SIGTERM, _sigterm_handler)
        server.serve_forever()
    finally:
        _unlockpid() # NOTE: execute sys.exit()?

def ForkServer(server):
    """Detach a process from the controlling terminal and run it in the
    background as a daemon.
    see: https://code.activestate.com/recipes/278731-creating-a-daemon-the-python-way/"""
    try:
        pid=os.fork() # The first fork
    except OSError as e:
        raise Exception("%s [%d]" % (e.strerror, e.errno))

    if (pid==0): # The first child
        os.setsid()
        signal.signal(signal.SIGHUP, signal.SIG_IGN)

        try:
            pid=os.fork() # The second fork
        except OSError as e:
            raise Exception("%s [%d]" % (e.strerror, e.errno))

        if (pid==0): # The second child, actual daemon goes here
            os.chdir("/")
            StartServer(server)
        else:
            os._exit(0) # _exit doesn't call atexit handlers, this exits the first child
    else:
        os._exit(0) # _exit doesn't call atexit handlers, this exits the first parent

def StopServer():
    """Stop the current running instance if it it exists"""
    pidfile=os.path.expanduser(PIDFILE)
    pid=""
    if os.path.exists(pidfile):
        with open(pidfile, 'r') as fd:
            pid=int(fd.readline())

    if pid:
        os.kill(pid, signal.SIGTERM)
        import time
        time.sleep(0.5) # so -sk can run properly, can't be arsed to check for exit
        return pid
    else:
        return None


def main():
    parser = ArgumentParser()
    parser.add_argument('-s', '--start', dest='start', action='store_true', help="start the server")
    parser.add_argument('-k', '--kill', dest='stop', action='store_true', help="sends sigterm to the current running instance, combine this with --start to reload")
    parser.add_argument('-f', '--fork', dest='fork', action='store_true', help="fork the server to the background")
    parser.add_argument('-a', '--add-user', dest='add', action='store_true', help="generate a password hash, store this in the config file")
    
    args = parser.parse_args()
    if args.add: # Create a user
        try:
            name, db = AddUser()
            if name and db:
                while True:
                        ans=_readline("Would you like to write changes to disk? (N/y/(p)review): ")
                        if _empty(ans) or ans.lower() in ("n", "no"):
                            break
                        elif ans.lower() in ( "yes", "y" ):
                            WriteUsers(USERSDB, USERSFILE)
                            break
                        elif ans.lower() == "p":
                            print("name=%s" % name)
                            for k in db:
                                print("%s=%s" % (k,db[k]))
                                continue
        except KeyboardInterrupt:
            print("\nAborting user creation")
            sys.exit(1)

        print("\nFinished user creation.")
        sys.exit(0)

    if args.stop: # Terminate running instance
        StopServer()

    if args.start: # Start the server
        userdb = LoadUsers(USERSFILE)
        server = InitServer(CONFIG.get("server", "address"), CONFIG.get("server", "port"), userdb)
        if args.fork:
            ForkServer(server)
        else:
            StartServer(server)

    else: # no args, show help
        parser.print_help()

if __name__ == '__main__':
    try:
        main()
    finally:
        WriteConfig(CONFIG, CONFIGFILE)
