#!/usr/bin/env python
## ~/.local/bin/automount: automatically mounts remove home dirs through sshfs using inotify
## configuration is done through ~/.config/automount/mounts file
## the syntax is: mountpoint user@host[:port]
## each mount directive should have its own line
## TODO: password auth?
## TODO: unmount on inactivity
## TODO: dependency checks: pyinotify sshfs

import sys,os,errno,subprocess,signal
import pyinotify

# Hosts file
# syntax is simple: user@host[:port] mountpoint
MOUNTSFILE=os.path.expanduser("~/.config/automount/mounts")

# Extra arguments passed to curlftpfs
SSHFSARGS="-o follow_symlinks"

def LoadMounts():
    """Load mounts from file."""
    mounts={}

    with open(MOUNTSFILE, 'r') as file:
        for mount in file.readlines():
            mountpoint,host = mount.strip().split()
            user,host=host.split("@")
            mountpoint=os.path.expanduser(mountpoint)
            mounts[mountpoint] = ( user, host )

    return mounts

def LoadManager(mounts):
    Manager= pyinotify.WatchManager()
    for mountpoint in mounts.keys():
        user,host = mounts[mountpoint][0],mounts[mountpoint][1]
        mount = ( mountpoint, user, host )
        Manager.add_watch(mountpoint, pyinotify.ALL_EVENTS, proc_fun=EventHandler(mount=mount))
    return Manager

class EventHandler(pyinotify.ProcessEvent):
    def my_init(self, mount=None):
        if not mount: raise TypeError("missing 1 required argument: mount")
        self.mountpoint = mount[0]
        self.user = mount[1]
        self.host = mount[2]

    def process_IN_OPEN(self, event):
        if os.path.ismount(self.mountpoint): return # already mounted, do nothing

        command="sshfs %s@%s: %s %s" % ( self.user, self.host, self.mountpoint, SSHFSARGS )
        print(command)
        Fork(lambda: subprocess.call(command.split()))

def CreateEmptyConfig():
    """Create an empty config file at MOUNTSFILE"""
    if not os.path.isdir(os.path.dirname(MOUNTSFILE)): # create directory first
        os.makedirs(os.path.dirname(MOUNTSFILE))

    open(MOUNTSFILE, 'a').close() # create an empty file

def Fork(callable):
    """Properly daemonize a callable
    see: https://code.activestate.com/recipes/278731-creating-a-daemon-the-python-way/"""
    try:
        pid=os.fork() # The first fork
    except OSError as e:
        raise Exception("%s [%d]" % (e.strerror, e.errno))

    if (pid==0): # The first child
        os.setsid()
        signal.signal(signal.SIGHUP, signal.SIG_IGN)

        try:
            pid=os.fork() # The second fork
        except OSError as e:
            raise Exception("%s [%d]" % (e.strerror, e.errno))

        if (pid==0): # The second child, actual daemon goes here
            os.chdir("/")
            callable()
        else:
            os._exit(0) # _exit doesn't call atexit handlers, this exits the first child
    else:
        os._exit(0) # _exit doesn't call atexit handlers, this exits the first parent

if __name__ == "__main__":
    if not os.path.isfile(MOUNTSFILE): # make sure a config file always exists
        CreateEmptyConfig()

    mounts=LoadMounts()
    Manager=LoadManager(mounts)
    Notifier = pyinotify.Notifier(Manager)
    if len(sys.argv) > 1 and ( sys.argv[1] == "-f" or sys.argv[1] == "--fork" ):
        Fork(Notifier.loop)
    else:
        Notifier.loop()
