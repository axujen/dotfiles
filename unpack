#!/usr/bin/env bash

source_dir="./home"
backup_dir="./dotfiles_backups"
logfile="./dotfiles.log"
verbose=false
clobber=false

usage="$(basename "$0") [-h] [-v] [-q] [-c] [-b path] [-l path] unpack dotfiles to their configured path
\n
\nwhere:
\n\t-h\tshow this help text and exit
\n\t-v\tverbose, show same information as the log
\n\t-q\tquiet, supress all output
\n\t-b\tbackup directory, default: $backup_dir
\n\t-l\tlogfile, default: $logfile
\n\t-s\tspecify directory to unpack, default: $source_dir
\n\t-c\toverwrite existing files"

function log(){
	# Log output to stdout and to a file.
	# Usage: log $text $force
	# text: The string the be logged
	# force: binary forcing the output to stdout regardless of the verbose 
	# argument
	# note: the quiet argument is still respected

	local text=$1
	[ ! -z $2 ] && local force=$2 || local force=false

	if [ -z $quiet ] ; then
		$force && echo $text || { $verbose && echo $text; }
	fi
	echo "[$(date +%T)] $text" >> $logfile
}

function install_file(){
	# Link a file from the dotfiles directory to its destination
	# Usage: install_file $file $dest
	# file:	path to the file to be unpacked
	# dest: destination localtion
	# note: all paths must be absolute

	local file=$1
	local dest=$2

	# Assuming that symlinks are previous dotfiles installs
	if [[ -L "$dest" ]]; then
		log "Deleting $dest because it was a symbolic link."
		rm -f "$dest"

	elif [[ -e "$dest" ]]; then
		# Never overwrite regular files without asking
		# TODO: y/n/a prompt.
		if [[ "$clobber" != true ]]; then
			log "Failed to install $file: destination exists."
			return
		fi

		# Backup regular files in case they are being overwritten
		bkp "$dest"
	fi

	log "Installing $file"
	ln -s "$file" "$dest"
}

function install_dir(){
	# Unpack a directory to its destination
	# Usage: install_dir $dir $dest
	# dir: directory to be installed
	# dest: destination path
	# note: all paths must be absolute

	local dir=$1
	local dest=$2

	# Make sure a directory always exists before trying to symlink into it
	[[ -e "$dest" ]] || mkdir "$dest"

	# This is deprecated behaviour based on when the script used to symlink dir
	# TODO: Error or prompt the user for action when the destinatio directory
	# is a symlink
	if [[ -L "$dest" ]]; then
		log "Deleting $dest because it was a symbolic link."
		rm -f "$dest"
	fi

	# If the destination is a regular file then back it up
	# TODO: Might require user confirmation on this.
	[[ -d "$dest" ]] || bkp "$dest"

	log "Unpacking directory $dir" true
	for item in $dir/*; do
		[[ $item == "$dir/*" ]] && break # emptry dir
		target="$dest/$(basename "$item")"
		[[ -d $item ]] && install_dir $item $target || install_file $item $target
	done
}

function bkp(){
	# Backup a file before overwriting it.
	# Usage: bkp $file
	# file: file to be backed up
	# TODO: redo the layout structure for the backups

	local file=$1
	local basename=`basename $file`
	local basedir="$backup_dir/$(echo $(dirname $file)|tr / _)"
	local bak="$basedir/${basename#.}"

	[[ -e "$basedir" ]] || mkdir -p "$basedir"

	if [[ -e "$bak" ]]; then
		i=1
		local new_bak=$bak.$i
		while [[ -e "$new_bak" ]] ; do
			i=$[i+1]
			new_bak=$bak.$i
		done
		bak=$new_bak
	fi

	log "Backing up $file"
	mv -f "$file" "$bak"
}

OPTIND=1
while getopts "hvqcs:" opt; do
	case "$opt" in
		h)
			echo -e $usage
			exit
			;;
		v)
			verbose=true;;
		q)
			quiet=true;;
		b)
			backup_dir=$OPTARG;;
		l)
			logfile=$OPTARG;;
		c)
			clobber=true;;
        s)
            source_dir="$OPTARG"
	esac
done

# Make sure we're unpacking from the script dir.
cd `dirname $0`

log "Unpacking your dotfiles." true

# Main Loop
for item in $source_dir/*; do
	item=`realpath $item`
	target="$HOME/.$(basename $item)"
	[[ -d "$item" ]] && install_dir $item $target || install_file $item $target
done

log "Done unpacking." true
